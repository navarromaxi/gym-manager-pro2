"use client";

import { useState, useEffect, useMemo, useRef, useCallback } from "react";
import type { Dispatch, SetStateAction } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Plus,
  Search,
  DollarSign,
  Edit,
  Trash2,
  Receipt,
  ShieldAlert,
} from "lucide-react";
import { supabase } from "@/lib/supabase";
import type {
  Member,
  Payment,
  Plan,
  PlanContract,
  CustomPlan,
  Invoice,
  GymInvoiceConfig,
} from "@/lib/supabase";
import {
  ensureCustomPlanMarker,
  stripCustomPlanMarker,
  extractCustomPlanIdFromDescription,
} from "@/lib/custom-plan-payments";
import { detectContractTable } from "@/lib/contract-table";
import type { ContractTableName } from "@/lib/contract-table";
import { isAutoGeneratedOneTimePayment } from "@/lib/one-time-payments";
import { DialogTrigger } from "@radix-ui/react-dialog";
interface PaymentManagementProps {
  payments: Payment[];
  setPayments: Dispatch<SetStateAction<Payment[]>>;
  members: Member[];
  setMembers: Dispatch<SetStateAction<Member[]>>;
  plans: Plan[];
  gymId: string;
  customPlans: CustomPlan[];
  invoices: Invoice[];
  setInvoices: Dispatch<SetStateAction<Invoice[]>>;
  gymInvoiceConfig?: GymInvoiceConfig | null;
}

interface PaymentInsight {
  isInstallment: boolean;
  balancePending: number | null;
  planPrice: number | null;
  nextInstallmentDue: string | null;
}

interface MemberInstallmentState {
  balance: number;
  planPrice: number | null;
  installmentActive: boolean;
  nextInstallmentDue: string | null;
}

type ReferenceFilterOption =
  | "all"
  | "new_plan"
  | "existing_plan"
  | "product"
  | "custom_plan";

const PAYMENTS_PER_BATCH = 10;

interface InvoiceFormState {
  facturareferencia: string;
  contnumero: string;
  contserie: string;
  seriereferencia: string;
  fechavencimiento: string;
  fechafacturacion: string;
  moneda: string;
  additionalinfo: string;
  terms_conditions: string;
  payment_type: number;
  cotizacion: number;
  typecfe: number;
  ordencompra: string;
  lugarentrega: string;
  periododesde: string;
  periodohasta: string;
  clicountry: string;
  nomneg: string;
  rutneg: string;
  dirneg: string;
  cityneg: string;
  stateneg: string;
  addinfoneg: string;
  lineas: string;
  indicadorfacturacion: string;
  typedoc: number;
  environment: string;
  facturaext: string;
  customerid: number;
  TipoTraslado: number;
}

const normalizeFacturaEnvironment = (
  value: string | null | undefined
): "PROD" | "TEST" | null => {
  if (!value) return null;

  const normalized = value.trim().toUpperCase();

  if (["PROD", "PRODUCCION", "PRODUCCIÓN", "PRODUCTION"].includes(normalized)) {
    return "PROD";
  }

  if (
    [
      "TEST",
      "HOMOLOGACION",
      "HOMOLOGACIÓN",
      "HOMOLOGA",
      "HOMO",
    ].includes(normalized)
  ) {
    return "TEST";
  }

  return null;
};

const FACTURA_LIVE_DEFAULT_ENVIRONMENT =
  normalizeFacturaEnvironment(process.env.NEXT_PUBLIC_FACTURA_LIVE_ENVIRONMENT) ||
  "TEST";

const hasConfigValue = (value: unknown) => {
  if (value === null || value === undefined) return false;
  if (typeof value === "string") return value.trim().length > 0;
  if (typeof value === "number") return !Number.isNaN(value);
  return false;
};

const toNumberOrNull = (
  value: string | number | null | undefined
): number | null => {
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (!trimmed) return null;
    const parsed = Number(trimmed);
    return Number.isNaN(parsed) ? null : parsed;
  }
  return null;
};

const sanitizeInvoiceText = (value: string) =>
  value.replace(/<col\/>/g, " ").replace(/\s+/g, " ").trim();

const sanitizeConfigString = (value: string | null | undefined) =>
  typeof value === "string" && value.trim().length > 0 ? value.trim() : "";

const mapPaymentMethodToFacturaPaymentType = (method: string | null | undefined) => {
  if (!method) return 1;
  const normalized = method.toLowerCase();
  if (normalized.includes("crédito")) return 2;
  if (normalized.includes("credito")) return 2;
  if (normalized.includes("débito")) return 3;
  if (normalized.includes("debito")) return 3;
  if (normalized.includes("transfer")) return 4;
  return 1;
};

const buildInvoiceErrorDetails = (payload: unknown): string | null => {
  if (!payload || typeof payload !== "object") {
    return null;
  }

  const record = payload as Record<string, unknown>;
  const details: string[] = [];

  const missing = Array.isArray(record.missing)
    ? record.missing.filter((value) => typeof value === "string")
    : [];

  if (missing.length > 0) {
    details.push(`Campos faltantes: ${missing.join(", ")}`);
  }

  const endpoint = typeof record.endpoint === "string" ? record.endpoint : null;
  if (endpoint) {
    details.push(`Endpoint: ${endpoint}`);
  }

  const externalResponse = (() => {
    const response = record.externalResponse as unknown;
    if (response && typeof response === "object") {
      const responseRecord = response as Record<string, unknown>;
      if (responseRecord.parsed && typeof responseRecord.parsed === "object") {
        return responseRecord.parsed;
      }
      return response;
    }
    return null;
  })();

  if (externalResponse) {
    details.push(
      `Respuesta interpretada:\n${JSON.stringify(externalResponse, null, 2)}`
    );
  }

  const rawResponse =
    typeof record.rawResponse === "string" && record.rawResponse.trim().length > 0
      ? record.rawResponse.trim()
      : null;

  if (rawResponse) {
    details.push(`Respuesta sin procesar:\n${rawResponse}`);
  }

  return details.length > 0 ? details.join("\n\n") : null;
};

type InvoiceDebugSource = "client" | "server" | "facturalive" | "database";

type InvoiceDebugStep = {
  at: string;
  step: string;
  source: InvoiceDebugSource;
  data?: unknown;
};

const SOURCE_LABELS: Record<InvoiceDebugSource, string> = {
  client: "Cliente",
  server: "Servidor",
  facturalive: "FacturaLive",
  database: "Base de datos",
};

const extractInvoiceDebugSteps = (payload: unknown): InvoiceDebugStep[] => {
  if (!payload || typeof payload !== "object") {
    return [];
  }

  const record = payload as Record<string, unknown>;
  const rawSteps = record.debugSteps;

  if (!Array.isArray(rawSteps)) {
    return [];
  }

  return rawSteps
    .map((item) => {
      if (!item || typeof item !== "object") {
        return null;
      }

      const entry = item as Record<string, unknown>;
      const step = typeof entry.step === "string" ? entry.step : null;
      const at = typeof entry.at === "string" ? entry.at : null;
      if (!step || !at) {
        return null;
      }

      const sourceValue = entry.source;
      const source: InvoiceDebugSource =
        sourceValue === "client" ||
        sourceValue === "server" ||
        sourceValue === "facturalive" ||
        sourceValue === "database"
          ? (sourceValue as InvoiceDebugSource)
          : "server";

      const result: InvoiceDebugStep = {
        step,
        at,
        source,
      };

      if ("data" in entry) {
        result.data = entry.data;
      }

      return result;
    })
    .filter((step): step is InvoiceDebugStep => Boolean(step));
};

const formatDebugStepData = (data: unknown): string => {
  if (data === null || data === undefined) {
    return "";
  }
  if (typeof data === "string") {
    return data;
  }
  if (typeof data === "number" || typeof data === "boolean") {
    return String(data);
  }
  try {
    return JSON.stringify(data, null, 2);
  } catch (error) {
    return String(data);
  }
};

const formatDebugStepTimestamp = (value: string): string => {
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return value;
  }
  return date.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  });
};

const buildInvoiceLineFromPayment = (payment: Payment) => {
  const baseDescription = (
    payment.plan?.trim() ||
    payment.description?.trim() ||
    `Pago ${payment.id}`
  ).replace(/,/g, " ");
  const safeDescription = sanitizeInvoiceText(baseDescription);
  const amount = Number(payment.amount ?? 0);
  const quantity = 1;
  const formattedQuantity = Number.isInteger(quantity)
    ? `${quantity.toFixed(1)}`
    : `${quantity}`;
  const unitPrice = Number.isFinite(amount)
    ? amount.toFixed(2)
    : Number(payment.amount || 0).toFixed(2);
  const taxIndicator = "3";
  const unitOfMeasure = "N/A";

  return `${safeDescription}</col/>${formattedQuantity}</col/>${unitPrice}</col/>0</col/>0</col/>${safeDescription}</col/>${taxIndicator}</col/>${unitOfMeasure}`;
}
const buildDefaultInvoiceForm = (
  payment: Payment,
  environment: string,
  gymConfig?: GymInvoiceConfig | null,
  options?: { periodStart?: string; periodEnd?: string }
): InvoiceFormState => {
  const issuedDate = payment.date
    ? payment.date.split("T")[0] ?? payment.date
    : new Date().toISOString().split("T")[0];
  const startDate = options?.periodStart
    ? options.periodStart
    : payment.start_date
    ? payment.start_date.split("T")[0] ?? payment.start_date
    : "";
  const periodEnd = options?.periodEnd ?? "";
  const configCustomerId = toNumberOrNull(gymConfig?.customerId);
  const defaultSeries = gymConfig?.series?.trim()
    ? gymConfig.series.trim()
    : "A-A-A";
  const defaultCurrency = gymConfig?.currency?.trim()
    ? gymConfig.currency.trim()
    : "UYU";
  const defaultCotizacion = toNumberOrNull(gymConfig?.cotizacion) ?? 1;
  const defaultTypecfe = toNumberOrNull(gymConfig?.typecfe) ?? 111;
  const defaultTipoTraslado = toNumberOrNull(gymConfig?.tipoTraslado) ?? 1;
  const defaultRutneg = sanitizeConfigString(gymConfig?.rutneg);
  const defaultDirneg = sanitizeConfigString(gymConfig?.dirneg);
  const defaultCityneg = sanitizeConfigString(gymConfig?.cityneg);
  const defaultStateneg = sanitizeConfigString(gymConfig?.stateneg);
  const defaultAddinfoneg = sanitizeConfigString(gymConfig?.addinfoneg);

  return {
    facturareferencia: payment.id,
    contnumero: "",
    contserie: "",
    seriereferencia: defaultSeries,
    fechavencimiento: "",
    fechafacturacion: issuedDate,
    moneda: defaultCurrency,
    additionalinfo: "",
    terms_conditions: "",
    payment_type: mapPaymentMethodToFacturaPaymentType(payment.method),
    cotizacion: defaultCotizacion,
    typecfe: defaultTypecfe,
    ordencompra: "",
    lugarentrega: "",
    periododesde: startDate,
    periodohasta: periodEnd,
    clicountry: "UY",
    nomneg: payment.member_name || "Socio",
    rutneg: defaultRutneg,
    dirneg: defaultDirneg,
    cityneg: defaultCityneg,
    stateneg: defaultStateneg,
    addinfoneg: defaultAddinfoneg,
    lineas: buildInvoiceLineFromPayment(payment),
    indicadorfacturacion: "",
    typedoc: 2,
    environment,
    facturaext: payment.id,
    customerid: configCustomerId ?? 0,
    TipoTraslado: defaultTipoTraslado,
  };
};

export function PaymentManagement({
  payments = [],
  setPayments,
  members = [],
  setMembers,
  plans = [],
  gymId,
  customPlans = [],
  invoices = [],
  setInvoices,
  gymInvoiceConfig,
}: PaymentManagementProps) {
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingPayment, setEditingPayment] = useState<Payment | null>(null);
  const [editingCustomPlanId, setEditingCustomPlanId] = useState<string | null>(
    null
  );
  const [editPaymentData, setEditPaymentData] = useState({
    amount: 0,
    date: new Date().toLocaleDateString("en-CA"),
    method: "",
    cardBrand: "",
    cardInstallments: 1,
    description: "",
    startDate: "",
  });
  const [searchTerm, setSearchTerm] = useState("");
  const [periodFilter, setPeriodFilter] = useState("all");
  const [memberSearchTerm, setMemberSearchTerm] = useState("");
  const [newPayment, setNewPayment] = useState({
    memberId: "",
    planId: "",
    method: "",
    cardBrand: "",
    cardInstallments: 1,
    date: new Date().toLocaleDateString("en-CA"),
    startDate: new Date().toLocaleDateString("en-CA"),
    type: "new_plan" as "new_plan" | "existing_plan" | "product",
    description: "",
    amount: 0,
    installments: 1,
    nextInstallmentDue: new Date().toLocaleDateString("en-CA"),
  });
  const previousInstallmentsRef = useRef(newPayment.installments);
  const previousPlanIdRef = useRef(newPayment.planId);
  const [planContract, setPlanContract] = useState<PlanContract | null>(null);
  const [methodFilter, setMethodFilter] = useState("all");
  const [installmentFilter, setInstallmentFilter] = useState("all");
  const [referenceFilter, setReferenceFilter] =
    useState<ReferenceFilterOption>("all");
  const [contractTable, setContractTable] = useState<ContractTableName | null>(
    null
  );
  const [visibleCount, setVisibleCount] = useState(PAYMENTS_PER_BATCH);
   const [isInvoiceDialogOpen, setIsInvoiceDialogOpen] = useState(false);
  const [invoiceDialogMode, setInvoiceDialogMode] = useState<
    "create" | "view"
  >("create");
  const [invoicePayment, setInvoicePayment] = useState<Payment | null>(null);
  const [invoiceForm, setInvoiceForm] = useState<InvoiceFormState | null>(null);
  const [selectedInvoiceRecord, setSelectedInvoiceRecord] =
    useState<Invoice | null>(null);
  const [invoiceError, setInvoiceError] = useState<string | null>(null);
  const [invoiceErrorDetails, setInvoiceErrorDetails] = useState<string | null>(
    null
  );
  const [invoiceDebugSteps, setInvoiceDebugSteps] = useState<
    InvoiceDebugStep[]
  >([]);
  const [isSendingInvoice, setIsSendingInvoice] = useState(false);
  const [invoiceSuccess, setInvoiceSuccess] = useState<string | null>(null);
  const appendClientDebugStep = useCallback(
    (step: string, data?: unknown) => {
      setInvoiceDebugSteps((previous) => [
        ...previous,
        {
          step,
          at: new Date().toISOString(),
          source: "client",
          ...(data !== undefined ? { data } : {}),
        },
      ]);
    },
    []
  );
  const facturaEnvironment = (() => {
    const normalized = normalizeFacturaEnvironment(
      gymInvoiceConfig?.environment
    );
    return normalized ?? FACTURA_LIVE_DEFAULT_ENVIRONMENT;
  })();

  const customPlansById = useMemo(() => {
    const map = new Map<string, CustomPlan>();
    customPlans.forEach((plan) => {
      map.set(plan.id, plan);
    });
    return map;
  }, [customPlans]);

  const invoicesByPaymentId = useMemo(() => {
    const map = new Map<string, Invoice>();
    invoices.forEach((invoice) => {
      map.set(invoice.payment_id, invoice);
    });
    return map;
  }, [invoices]);

  const requiredInvoiceConfig: { key: keyof GymInvoiceConfig; label: string }[] = [
    { key: "userId", label: "userid" },
    { key: "companyId", label: "empresaid" },
    { key: "branchCode", label: "codsucursal" },
    { key: "branchId", label: "sucursal" },
  ];

  const missingInvoiceConfig = useMemo(() => {
    return requiredInvoiceConfig
      .filter(({ key }) => !hasConfigValue(gymInvoiceConfig?.[key]))
      .map(({ label }) => label);
  }, [gymInvoiceConfig]);

  const isInvoiceConfigReady = missingInvoiceConfig.length === 0;

  const findPlanForPayment = (payment: Payment): Plan | null => {
    if (payment.plan_id) {
      const byId = plans.find((plan) => plan.id === payment.plan_id);
      if (byId) {
        return byId;
      }
    }

    if (payment.plan) {
      const byName = plans.find((plan) => plan.name === payment.plan);
      if (byName) {
        return byName;
      }
    }

    return null;
  };

  useEffect(() => {
    const checkTable = async () => {
      const table = await detectContractTable();
      setContractTable(table);
    };
    checkTable();
  }, []);
  const paymentMethods = [
    "Efectivo",
    "Transferencia",
    "Tarjeta de Débito",
    "Tarjeta de Crédito",
  ];

  const cardBrands = [
    "VISA",
    "OCA",
    "MASTER",
    "CABAL",
    "AMEX",
    "TARJETA D",
    "MERCADO PAGO",
  ];

   const facturaPaymentTypeOptions = [
    { value: 1, label: "Contado (1)" },
    { value: 2, label: "Tarjeta de crédito (2)" },
    { value: 3, label: "Tarjeta de débito (3)" },
    { value: 4, label: "Transferencia bancaria (4)" },
  ];

  const facturaEnvironmentOptions = ["TEST", "PROD"];

  const resetInvoiceDialogState = () => {
    setInvoicePayment(null);
    setInvoiceForm(null);
    setSelectedInvoiceRecord(null);
    setInvoiceError(null);
    setInvoiceErrorDetails(null);
    setInvoiceSuccess(null);
    setInvoiceDialogMode("create");
    setIsSendingInvoice(false);
    setInvoiceDebugSteps([]);
  };

  const openInvoiceDialog = (
    payment: Payment,
    existingInvoice?: Invoice | null
  ) => {
    setInvoicePayment(payment);
    setInvoiceError(null);
    setInvoiceErrorDetails(null);
    setInvoiceSuccess(null);
    setInvoiceDebugSteps([]);

    if (existingInvoice) {
      setInvoiceDialogMode("view");
      setSelectedInvoiceRecord(existingInvoice);
      setInvoiceForm(null);
    } else {
      const periodStart = payment.start_date
        ? payment.start_date.split("T")[0] ?? payment.start_date
        : "";
      let periodEnd = "";
      if (periodStart) {
        const relatedPlan = findPlanForPayment(payment);
        if (relatedPlan) {
          const computedEnd = calculatePlanEndDate(periodStart, relatedPlan);
          periodEnd = computedEnd || "";
        }
      }
      const defaults = buildDefaultInvoiceForm(
        payment,
        facturaEnvironment,
        gymInvoiceConfig,
        {
          periodStart,
          periodEnd,
        }
      );
      setInvoiceDialogMode("create");
      setInvoiceForm(defaults);
      setSelectedInvoiceRecord(null);
    }

    setIsInvoiceDialogOpen(true);
  };

  const closeInvoiceDialog = () => {
    setIsInvoiceDialogOpen(false);
    resetInvoiceDialogState();
  };

  const handleInvoiceFieldChange = <K extends keyof InvoiceFormState>(
    field: K,
    value: InvoiceFormState[K]
  ) => {
    setInvoiceForm((prev) => (prev ? { ...prev, [field]: value } : prev));
  };

  const handleSendInvoice = async () => {
    if (!invoicePayment || !invoiceForm) return;

     const initialStep: InvoiceDebugStep = {
      step: "Inicio del proceso de facturación desde el cliente",
      at: new Date().toISOString(),
      source: "client",
      data: {
        gymId,
        paymentId: invoicePayment.id,
        memberId: invoicePayment.member_id,
        amount: invoicePayment.amount,
      },
    };
    setInvoiceDebugSteps([initialStep]);

    if (!gymId) {
      appendClientDebugStep("Proceso detenido: no hay gimnasio seleccionado", {
        gymId,
      });
      setInvoiceError(
        "Debes seleccionar un gimnasio antes de emitir facturas."
      );
      setInvoiceErrorDetails(null);
      return;
    }

    if (!isInvoiceConfigReady) {
       appendClientDebugStep(
        "Proceso detenido: configuración de facturación incompleta",
        {
          missing: missingInvoiceConfig,
        }
      );
      setInvoiceError(
        `Completa en Supabase los campos obligatorios (${missingInvoiceConfig.join(", ")}) y la contraseña invoice_password antes de facturar.`
      );
      setInvoiceErrorDetails(null);
      return;
    }

    setIsSendingInvoice(true);
    setInvoiceError(null);
    setInvoiceErrorDetails(null);
    setInvoiceSuccess(null);

     const requestPreview = {
      gymId,
      paymentId: invoicePayment.id,
      memberId: invoicePayment.member_id,
      memberName: invoicePayment.member_name,
      amount: invoicePayment.amount,
      invoice: {
        ...invoiceForm,
        lineasLength: invoiceForm.lineas?.length ?? 0,
        lineasPreview: invoiceForm.lineas?.slice(0, 200) ?? "",
      },
    };

    appendClientDebugStep("Enviando solicitud al backend /api/invoices", {
      endpoint: "/api/invoices",
      payload: requestPreview,
    });

    try {
      const response = await fetch("/api/invoices", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          gymId,
          paymentId: invoicePayment.id,
          memberId: invoicePayment.member_id,
          memberName: invoicePayment.member_name,
          amount: invoicePayment.amount,
          invoice: invoiceForm,
        }),
      });

      appendClientDebugStep("Respuesta recibida del backend", {
        status: response.status,
        ok: response.ok,
      });

      let payload: unknown = null;
      try {
        payload = await response.json();
        appendClientDebugStep(
          "Respuesta JSON del backend interpretada correctamente"
        );
      } catch (parseError) {
        appendClientDebugStep(
          "No se pudo interpretar la respuesta JSON del backend",
          {
            error:
              parseError instanceof Error
                ? parseError.message
                : String(parseError),
          }
        );
        setInvoiceError(
          "No se pudo interpretar la respuesta del servicio de facturación."
        );
        setInvoiceErrorDetails(null);
        return;
      }

      const serverSteps = extractInvoiceDebugSteps(payload);
      if (serverSteps.length > 0) {
        setInvoiceDebugSteps((previous) => [...previous, ...serverSteps]);
      } else {
        appendClientDebugStep(
          "El backend no proporcionó pasos de depuración adicionales"
        );
      }

      if (!response.ok) {
        const payloadRecord = payload as Record<string, unknown> | null;
        const message =
          payloadRecord && typeof payloadRecord.error === "string"
            ? payloadRecord.error
            : "No se pudo generar la factura. Intenta nuevamente.";
        setInvoiceError(message);
        setInvoiceErrorDetails(buildInvoiceErrorDetails(payload));
        return;
      }

      const payloadRecord = payload as Record<string, unknown> | null;
      const newInvoice: Invoice | undefined =
        payloadRecord?.invoice as Invoice | undefined;
      if (newInvoice) {
        setInvoices((prev) => {
          const existingIndex = prev.findIndex(
            (invoice) => invoice.id === newInvoice.id
          );
          if (existingIndex >= 0) {
            const copy = [...prev];
            copy[existingIndex] = newInvoice;
            return copy;
          }
          return [newInvoice, ...prev];
        });

        setSelectedInvoiceRecord(newInvoice);
        setInvoiceDialogMode("view");
        setInvoiceForm(null);
        setInvoiceSuccess("Factura generada correctamente.");
        const technicalDetails = buildInvoiceErrorDetails(payload);
        if (technicalDetails) {
          appendClientDebugStep("Detalle técnico del backend", {
            technicalDetails,
          });
        }
        setInvoiceErrorDetails(null);
        appendClientDebugStep("Factura registrada correctamente", {
          invoiceId: newInvoice.id,
        });
      } else {
        appendClientDebugStep(
          "El backend no devolvió el registro de la factura generada"
        );
        setInvoiceError(
          "La factura se generó, pero no recibimos la confirmación esperada."
        );
        setInvoiceErrorDetails(buildInvoiceErrorDetails(payload));
      }
    } catch (error) {
      console.error("Error enviando factura", error);
      appendClientDebugStep(
        "Error de red o inesperado al contactar al backend",
        {
          error: error instanceof Error ? error.message : String(error),
        }
      );
      setInvoiceError(
        "Ocurrió un error inesperado al conectar con el servicio de facturación."
      );
      setInvoiceErrorDetails(null);
    } finally {
      setIsSendingInvoice(false);
    }
  };

  const getPlanPrice = (payment: Payment) => {
    if (payment.plan_id) {
      const planById = plans.find((plan) => plan.id === payment.plan_id);
      if (planById) return planById.price;
    }
    if (payment.plan) {
      const planByName = plans.find((plan) => plan.name === payment.plan);
      if (planByName) return planByName.price;
    }
    return 0;
  };

  const getPaymentReferenceType = (payment: Payment): ReferenceFilterOption => {
    if (payment.type === "product") {
      return "product";
    }

    if (payment.type === "custom_plan") {
      return "custom_plan";
    }

    const hasStartDate =
      typeof payment.start_date === "string" &&
      payment.start_date.trim() !== "";

    return hasStartDate ? "new_plan" : "existing_plan";
  };

  const getEffectivePaymentDate = (payment: Payment) =>
    payment.start_date && payment.start_date.trim() !== ""
      ? payment.start_date
      : payment.date;

  const findLatestPlanPaymentDate = (list: Payment[], memberId: string) => {
    const relevantPayments = list.filter(
      (payment) =>
        payment.member_id === memberId &&
        (!payment.type || payment.type === "plan")
    );

    if (relevantPayments.length === 0) {
      return null;
    }

    const latestPayment = relevantPayments.reduce((latest, current) => {
      const latestDate = parseLocalDate(getEffectivePaymentDate(latest));
      const currentDate = parseLocalDate(getEffectivePaymentDate(current));
      return currentDate > latestDate ? current : latest;
    });

    return getEffectivePaymentDate(latestPayment);
  };

  const parseLocalDate = (dateStr: string) => {
    const [year, month, day] = dateStr.split("-").map(Number);
    return new Date(year, month - 1, day);
  };

  const parseDueDate = (value: string | null | undefined) => {
    if (!value) return null;
    const isoPattern = /^\d{4}-\d{2}-\d{2}$/;
    const date = isoPattern.test(value)
      ? parseLocalDate(value)
      : new Date(value);
    if (Number.isNaN(date.getTime())) return null;
    date.setHours(0, 0, 0, 0);
    return date;
  };

  const formatDueDate = (value: string | null | undefined) => {
    if (!value) return null;
    const parsed = parseDueDate(value);
    if (!parsed) return value;
    return parsed.toLocaleDateString();
  };

  const calculatePlanEndDate = (startDate: string, plan?: Plan | null) => {
    if (!startDate) return "";
    const baseDate = new Date(`${startDate}T00:00:00`);
    if (Number.isNaN(baseDate.getTime())) {
      return startDate;
    }
    if (plan) {
      if (plan.duration_type === "days") {
        baseDate.setDate(baseDate.getDate() + plan.duration);
      } else if (plan.duration_type === "months") {
        baseDate.setMonth(baseDate.getMonth() + plan.duration);
      } else if (plan.duration_type === "years") {
        baseDate.setFullYear(baseDate.getFullYear() + plan.duration);
      }
    }

    return baseDate.toISOString().split("T")[0];
  };

  const updateMemberAfterPlanEdit = async (
    originalPayment: Payment,
    updatedPaymentsList: Payment[],
    newAmount: number
  ) => {
    const member = members.find((m) => m.id === originalPayment.member_id);
    if (!member) return;

    const delta = newAmount - originalPayment.amount;
    const currentBalance = member.balance_due || 0;
    const updatedBalance = Math.max(currentBalance - delta, 0);
    const latestDate = findLatestPlanPaymentDate(
      updatedPaymentsList,
      member.id
    );

    const memberUpdate: Record<string, any> = {
      balance_due: updatedBalance,
      last_payment: latestDate ?? null,
    };

    const { error: memberError } = await supabase
      .from("members")
      .update(memberUpdate)
      .eq("id", member.id);

    if (memberError) throw memberError;

    setMembers((prevMembers) =>
      prevMembers.map((m) =>
        m.id === member.id
          ? {
              ...m,
              balance_due: updatedBalance,
              last_payment: latestDate ?? "",
            }
          : m
      )
    );
  };

  const revertMemberAfterPlanDeletion = async (
    removedPayment: Payment,
    remainingPayments: Payment[]
  ) => {
    const member = members.find((m) => m.id === removedPayment.member_id);
    if (!member) return;

    const currentBalance = member.balance_due || 0;
    let updatedBalance = currentBalance;

    if (removedPayment.start_date) {
      const planPrice = getPlanPrice(removedPayment);
      updatedBalance = Math.max(
        currentBalance - planPrice + removedPayment.amount,
        0
      );
    } else {
      updatedBalance = Math.max(currentBalance + removedPayment.amount, 0);
    }

    const latestDate = findLatestPlanPaymentDate(remainingPayments, member.id);

    const memberUpdate: Record<string, any> = {
      balance_due: updatedBalance,
      last_payment: latestDate ?? null,
    };

    const { error: memberError } = await supabase
      .from("members")
      .update(memberUpdate)
      .eq("id", member.id);

    if (memberError) throw memberError;

    setMembers((prevMembers) =>
      prevMembers.map((m) =>
        m.id === member.id
          ? {
              ...m,
              balance_due: updatedBalance,
              last_payment: latestDate ?? "",
            }
          : m
      )
    );
  };

  const adjustContractAfterPlanDeletion = async (payment: Payment) => {
    if (!contractTable || !payment.plan_id) return;

    try {
      const { data, error } = await supabase
        .from(contractTable)
        .select("*")
        .eq("member_id", payment.member_id)
        .eq("plan_id", payment.plan_id)
        .maybeSingle();

      if (error) {
        console.warn("Error obteniendo contrato de plan:", error);
        return;
      }

      if (!data) return;

      const contract = data as PlanContract;
      const newInstallmentsPaid = Math.max(
        (contract.installments_paid || 0) - 1,
        0
      );

      if (newInstallmentsPaid <= 0) {
        const { error: deleteError } = await supabase
          .from(contractTable)
          .delete()
          .eq("id", contract.id);
        if (deleteError) {
          console.warn("Error eliminando contrato de plan:", deleteError);
        }
      } else {
        const { error: updateError } = await supabase
          .from(contractTable)
          .update({ installments_paid: newInstallmentsPaid })
          .eq("id", contract.id);
        if (updateError) {
          console.warn("Error actualizando contrato de plan:", updateError);
        }
      }
    } catch (error) {
      console.warn("Error ajustando contrato tras eliminar pago:", error);
    }
  };

  const paymentInsights = useMemo(() => {
    const planIdMap = new Map<string, Plan>();
    const planNameMap = new Map<string, Plan>();
    plans.forEach((plan) => {
      planIdMap.set(plan.id, plan);
      planNameMap.set(plan.name, plan);
    });

    const memberMap = new Map<string, Member>();
    members.forEach((member) => {
      memberMap.set(member.id, member);
    });

    const memberStates = new Map<string, MemberInstallmentState>();
    const insights = new Map<string, PaymentInsight>();

    const getTimeValue = (value: string) => {
      const parsed = parseLocalDate(value);
      const time = parsed.getTime();
      return Number.isNaN(time) ? 0 : time;
    };

    const orderedPayments = [...payments].sort(
      (a, b) => getTimeValue(a.date) - getTimeValue(b.date)
    );

    orderedPayments.forEach((payment) => {
      const member = memberMap.get(payment.member_id);
      const previousState = memberStates.get(payment.member_id) ?? {
        balance: 0,
        planPrice: null,
        installmentActive: false,
        nextInstallmentDue: member?.next_installment_due ?? null,
      };

      if (payment.type && payment.type !== "plan") {
        memberStates.set(payment.member_id, previousState);
        insights.set(payment.id, {
          isInstallment: false,
          balancePending: null,
          planPrice: null,
          nextInstallmentDue: null,
        });
        return;
      }

      const planFromId = payment.plan_id
        ? planIdMap.get(payment.plan_id)
        : undefined;
      const planFromName =
        !planFromId && payment.plan ? planNameMap.get(payment.plan) : undefined;
      const effectivePlanPrice =
        planFromId?.price ??
        planFromName?.price ??
        previousState.planPrice ??
        member?.plan_price ??
        null;

      if (payment.start_date) {
        const targetPrice = effectivePlanPrice ?? payment.amount;
        const balanceAfter = Math.max(targetPrice - payment.amount, 0);
        const isInstallment = balanceAfter > 0;
        const inferredNextDue = isInstallment
          ? member?.next_installment_due ??
            previousState.nextInstallmentDue ??
            (payment.start_date
              ? calculatePlanEndDate(
                  payment.start_date,
                  planFromId ?? planFromName ?? null
                )
              : null)
          : null;

        memberStates.set(payment.member_id, {
          balance: balanceAfter,
          planPrice: targetPrice,
          installmentActive: balanceAfter > 0,
          nextInstallmentDue: inferredNextDue,
        });

        insights.set(payment.id, {
          isInstallment,
          balancePending: balanceAfter,
          planPrice: targetPrice,
          nextInstallmentDue: inferredNextDue,
        });
        return;
      }

      const balanceBefore = previousState.balance ?? 0;
      const newBalance = Math.max(balanceBefore - payment.amount, 0);
      const wasInstallment =
        previousState.installmentActive || balanceBefore > 0 || newBalance > 0;
      const nextDue =
        newBalance > 0
          ? previousState.nextInstallmentDue ??
            member?.next_installment_due ??
            null
          : null;

      memberStates.set(payment.member_id, {
        balance: newBalance,
        planPrice: effectivePlanPrice ?? previousState.planPrice,
        installmentActive: newBalance > 0,
        nextInstallmentDue: nextDue,
      });

      insights.set(payment.id, {
        isInstallment: wasInstallment,
        balancePending: newBalance,
        planPrice:
          effectivePlanPrice ??
          previousState.planPrice ??
          member?.plan_price ??
          null,
        nextInstallmentDue: nextDue,
      });
    });
    return insights;
  }, [members, payments, plans]);

  const membersById = useMemo(() => {
    const map = new Map<string, Member>();
    members.forEach((member) => {
      map.set(member.id, member);
    });
    return map;
  }, [members]);

  const latestPlanPaymentByMember = useMemo(() => {
    const map = new Map<string, string>();
    (payments || []).forEach((payment) => {
      if (payment.type && payment.type !== "plan") {
        return;
      }

      const effectiveDate = getEffectivePaymentDate(payment);
      if (!effectiveDate) {
        return;
      }

      const previousDate = map.get(payment.member_id);
      if (!previousDate) {
        map.set(payment.member_id, effectiveDate);
        return;
      }

      const current = parseLocalDate(effectiveDate).getTime();
      const previous = parseLocalDate(previousDate).getTime();

      if (current > previous) {
        map.set(payment.member_id, effectiveDate);
      }
    });
    return map;
  }, [payments]);

  useEffect(() => {
    const fetchExistingContract = async () => {
      if (
        newPayment.type === "existing_plan" &&
        newPayment.memberId &&
        contractTable
      ) {
        const memberPlan = members.find(
          (m) => m.id === newPayment.memberId
        )?.plan;
        const plan = plans.find((p) => p.name === memberPlan);
        if (plan) {
          const { data, error } = await supabase
            .from(contractTable)
            .select("*")
            .eq("member_id", newPayment.memberId)
            .eq("plan_id", plan.id)
            .single();
          setPlanContract(error ? null : data ?? null);
        } else {
          setPlanContract(null);
        }
      }
    };
    fetchExistingContract();
  }, [newPayment.type, newPayment.memberId, contractTable, members, plans]);

  // Filtrar miembros para el buscador
  const filteredMembersForSearch = members.filter((member) =>
    member.name.toLowerCase().includes(memberSearchTerm.toLowerCase())
  );

  // Pagos filtrados y ordenados según los controles actuales
  const filteredPayments = useMemo(() => {
    let filtered = (payments || []).filter((payment) =>
      payment.member_name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    if (methodFilter !== "all") {
      filtered = filtered.filter((payment) => payment.method === methodFilter);
    }

    if (periodFilter !== "all") {
      const currentDate = new Date();

      filtered = filtered.filter((payment) => {
        const paymentDate = parseLocalDate(payment.date);

        switch (periodFilter) {
          case "current_month":
            return (
              paymentDate.getMonth() === currentDate.getMonth() &&
              paymentDate.getFullYear() === currentDate.getFullYear()
            );
          case "previous_month":
            const previousMonth =
              currentDate.getMonth() === 0 ? 11 : currentDate.getMonth() - 1;
            const previousYear =
              currentDate.getMonth() === 0
                ? currentDate.getFullYear() - 1
                : currentDate.getFullYear();
            return (
              paymentDate.getMonth() === previousMonth &&
              paymentDate.getFullYear() === previousYear
            );
          case "last_6_months":
            const sixMonthsAgo = new Date();
            sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
            return paymentDate >= sixMonthsAgo;
          case "current_year":
            return paymentDate.getFullYear() === currentDate.getFullYear();
          default:
            return true;
        }
      });
    }

    if (referenceFilter !== "all") {
      filtered = filtered.filter(
        (payment) => getPaymentReferenceType(payment) === referenceFilter
      );
    }

    if (installmentFilter !== "all") {
      filtered = filtered.filter((payment) => {
        if (payment.type && payment.type !== "plan") {
          return false;
        }

        const insight = paymentInsights.get(payment.id);
        const member = membersById.get(payment.member_id);
        const pending = insight?.balancePending;
        const memberBalance =
          typeof member?.balance_due === "number" ? member.balance_due : null;
        const nextDueRaw =
          insight?.nextInstallmentDue ?? member?.next_installment_due ?? null;
        const dueDate = parseDueDate(nextDueRaw);
        const latestEffectiveDate = latestPlanPaymentByMember.get(
          payment.member_id
        );
        const isLatestPlanPayment =
          !!latestEffectiveDate &&
          getEffectivePaymentDate(payment) === latestEffectiveDate;
        const planEndDate = member?.next_payment
          ? parseDueDate(member.next_payment)
          : null;
        const pendingAmount =
          typeof pending === "number"
            ? pending
            : typeof memberBalance === "number"
            ? memberBalance
            : 0;

        switch (installmentFilter) {
          case "pending_balance":
            if (typeof pending === "number") {
              return pending > 0;
            }
            return (memberBalance ?? 0) > 0;
          case "due_soon": {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const limitDate = new Date(today);
            limitDate.setDate(limitDate.getDate() + 10);
            const planEndingSoon =
              isLatestPlanPayment &&
              !!planEndDate &&
              planEndDate >= today &&
              planEndDate <= limitDate;

            const installmentDueSoon =
              isLatestPlanPayment &&
              pendingAmount > 0 &&
              !!dueDate &&
              dueDate >= today &&
              dueDate <= limitDate;

            return planEndingSoon || installmentDueSoon;
          }
          case "overdue": {
            const reference = new Date();
            reference.setHours(0, 0, 0, 0);
            const planExpired =
              isLatestPlanPayment && !!planEndDate && planEndDate < reference;

            const installmentOverdue =
              isLatestPlanPayment &&
              pendingAmount > 0 &&
              !!dueDate &&
              dueDate < reference;

            return planExpired || installmentOverdue;
          }
          default:
            return true;
        }
      });
    }

    return filtered.sort(
      (a, b) =>
        parseLocalDate(b.date).getTime() - parseLocalDate(a.date).getTime()
    );
  }, [
    payments,
    searchTerm,
    methodFilter,
    periodFilter,
    installmentFilter,
    referenceFilter,
    paymentInsights,
    membersById,
    latestPlanPaymentByMember,
  ]);

  useEffect(() => {
    setVisibleCount(PAYMENTS_PER_BATCH);
  }, [
    searchTerm,
    methodFilter,
    periodFilter,
    installmentFilter,
    referenceFilter,
    payments,
  ]);

  const visiblePayments = useMemo(() => {
    if (!filteredPayments.length) return [];
    const limit = Math.min(visibleCount, filteredPayments.length);
    return filteredPayments.slice(0, limit);
  }, [filteredPayments, visibleCount]);

  const canLoadMore = visibleCount < filteredPayments.length;

  const handleLoadMorePayments = () => {
    setVisibleCount((prev) =>
      Math.min(prev + PAYMENTS_PER_BATCH, filteredPayments.length)
    );
  };

  const selectedMember = members.find((m) => m.id === newPayment.memberId);
  const selectedPlan =
    newPayment.type === "existing_plan"
      ? plans.find((p) => p.name === selectedMember?.plan)
      : plans.find((p) => p.id === newPayment.planId);
  const balanceDueActual = selectedMember?.balance_due || 0;
  const remainingBalance = Math.max(balanceDueActual - newPayment.amount, 0);
  const shouldAskNextInstallmentDue =
    newPayment.type === "existing_plan" &&
    balanceDueActual > 0 &&
    newPayment.amount > 0 &&
    remainingBalance > 0;
  const maxPlanAmount =
    newPayment.type === "new_plan" && selectedPlan
      ? planContract
        ? balanceDueActual
        : Math.max(selectedPlan.price + balanceDueActual, 0)
      : 0;

  const calculatedPlanEndDate = useMemo(() => {
    if (newPayment.type !== "new_plan") return "";
    return calculatePlanEndDate(newPayment.startDate, selectedPlan);
  }, [newPayment.type, newPayment.startDate, selectedPlan]);

  const nextInstallmentDueValue =
    newPayment.type === "new_plan"
      ? newPayment.installments === 1
        ? calculatedPlanEndDate
        : newPayment.nextInstallmentDue || calculatedPlanEndDate
      : newPayment.type === "existing_plan"
      ? newPayment.nextInstallmentDue ||
        selectedMember?.next_installment_due ||
        ""
      : "";

  useEffect(() => {
    const prevInstallments = previousInstallmentsRef.current;
    const prevPlanId = previousPlanIdRef.current;
    const planChanged =
      newPayment.type === "new_plan" &&
      newPayment.planId &&
      newPayment.planId !== prevPlanId;

    if (
      newPayment.type === "new_plan" &&
      selectedPlan &&
      newPayment.installments === 1 &&
      (newPayment.amount === 0 || prevInstallments !== 1 || planChanged)
    ) {
      setNewPayment((prev) => ({
        ...prev,
        amount: selectedPlan.price,
      }));
    }

    previousInstallmentsRef.current = newPayment.installments;
    previousPlanIdRef.current = newPayment.planId;
  }, [
    newPayment.amount,
    newPayment.installments,
    newPayment.planId,
    newPayment.type,
    selectedPlan,
  ]);

  // FUNCIÓN ACTUALIZADA PARA REGISTRAR PAGO Y RENOVAR SOCIO
  const handleAddPayment = async () => {
    try {
      if (!selectedMember) return;

      const paymentId = `${gymId}_payment_${Date.now()}`;

      if (newPayment.type === "new_plan") {
        if (!selectedPlan) return;
        if (newPayment.amount < 0) {
          alert("El monto no puede ser negativo");
          return;
        }
        if (newPayment.amount > maxPlanAmount) {
          alert(
            `El monto no puede ser mayor a ${maxPlanAmount.toLocaleString()}`
          );
          return;
        }
        if (
          newPayment.installments > 1 &&
          (!newPayment.nextInstallmentDue ||
            newPayment.nextInstallmentDue === "")
        ) {
          alert("Debes ingresar el vencimiento de la próxima cuota");
          return;
        }

        let currentContract = planContract;
        const contractId =
          planContract?.id || `${newPayment.memberId}_contract_${Date.now()}`;

        const isFirstInstallment = !currentContract;

        if (isFirstInstallment && contractTable) {
          const newContract: PlanContract = {
            id: contractId,
            gym_id: gymId,
            member_id: newPayment.memberId,
            plan_id: selectedPlan.id,
            installments_total: newPayment.installments,
            installments_paid: 1,
          };
          const { error: contractError } = await supabase
            .from(contractTable)
            .insert([newContract]);
          if (contractError) {
            console.warn("Error registrando contrato de plan:", contractError);
          } else {
            currentContract = newContract;
            setPlanContract(currentContract);
          }
        } else if (currentContract && contractTable) {
          const { error: contractError } = await supabase
            .from(contractTable)
            .update({
              installments_paid: currentContract.installments_paid + 1,
            })
            .eq("id", currentContract.id);
          if (contractError) {
            console.warn("Error actualizando contrato de plan:", contractError);
          }
          currentContract = {
            ...currentContract,
            installments_paid: currentContract.installments_paid + 1,
          };
          setPlanContract(currentContract);
        }

        const paymentDescription =
          newPayment.description.trim() || selectedPlan.name;

        const payment: Payment = {
          id: paymentId,
          gym_id: gymId,
          member_id: newPayment.memberId,
          member_name: selectedMember.name,
          amount: newPayment.amount,
          date: newPayment.date,
          start_date: newPayment.startDate,
          plan: selectedPlan.name,
          method: newPayment.method,
          card_brand: ["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
            newPayment.method
          )
            ? newPayment.cardBrand
            : undefined,
          card_installments:
            newPayment.method === "Tarjeta de Crédito"
              ? newPayment.cardInstallments
              : undefined,
          type: "plan",
          description: paymentDescription,
          plan_id: selectedPlan.id,
        };

        const { error: paymentError } = await supabase
          .from("payments")
          .insert([payment]);
        if (paymentError) throw paymentError;

        // Actualizar el socio con el nuevo plan
        const planStart = parseLocalDate(newPayment.startDate);
        const nextPayment = new Date(planStart);

        if (selectedPlan.duration_type === "days") {
          nextPayment.setDate(nextPayment.getDate() + selectedPlan.duration);
        } else if (selectedPlan.duration_type === "months") {
          nextPayment.setMonth(nextPayment.getMonth() + selectedPlan.duration);
        } else if (selectedPlan.duration_type === "years") {
          nextPayment.setFullYear(
            nextPayment.getFullYear() + selectedPlan.duration
          );
        }

        const nextPaymentISO = nextPayment.toISOString().split("T")[0];
        const nextInstallmentDue =
          newPayment.installments === 1
            ? nextPaymentISO
            : newPayment.nextInstallmentDue || nextPaymentISO;

        const newBalance = isFirstInstallment
          ? balanceDueActual + selectedPlan.price - newPayment.amount
          : balanceDueActual - newPayment.amount;

        const { error: memberError } = await supabase
          .from("members")
          .update({
            plan: selectedPlan.name,
            plan_price: selectedPlan.price,
            balance_due: Math.max(newBalance, 0),
            last_payment: newPayment.startDate,
            next_payment: nextPaymentISO,
            next_installment_due: nextInstallmentDue,
            status: "active",
          })
          .eq("id", selectedMember.id);
        if (memberError) throw memberError;

        const updatedMember = {
          ...selectedMember,
          plan: selectedPlan.name,
          plan_price: selectedPlan.price,
          balance_due: Math.max(newBalance, 0),
          last_payment: newPayment.startDate,
          next_payment: nextPaymentISO,
          next_installment_due: nextInstallmentDue,
          status: "active" as const,
        };

        setPayments([...payments, payment]);
        setMembers(
          members.map((m) => (m.id === selectedMember.id ? updatedMember : m))
        );
      } else if (newPayment.type === "existing_plan") {
        if (!selectedPlan) return;
        if (newPayment.amount < 0) {
          alert("El monto no puede ser negativo");
          return;
        }
        if (newPayment.amount > balanceDueActual) {
          alert(
            `El monto no puede ser mayor a ${balanceDueActual.toLocaleString()}`
          );
          return;
        }

        const newBalance = balanceDueActual - newPayment.amount;
        if (
          newBalance > 0 &&
          (!newPayment.nextInstallmentDue ||
            newPayment.nextInstallmentDue.trim() === "")
        ) {
          alert("Debes ingresar el vencimiento de la próxima cuota");
          return;
        }

        if (planContract && contractTable) {
          const { error: contractError } = await supabase
            .from(contractTable)
            .update({
              installments_paid: planContract.installments_paid + 1,
            })
            .eq("id", planContract.id);
          if (contractError) {
            console.warn("Error actualizando contrato de plan:", contractError);
          } else {
            setPlanContract({
              ...planContract,
              installments_paid: planContract.installments_paid + 1,
            });
          }
        }

        const paymentDescription =
          newPayment.description.trim() || selectedPlan.name;

        const payment: Payment = {
          id: paymentId,
          gym_id: gymId,
          member_id: newPayment.memberId,
          member_name: selectedMember.name,
          amount: newPayment.amount,
          date: newPayment.date,
          plan: selectedMember.plan,
          method: newPayment.method,
          card_brand: ["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
            newPayment.method
          )
            ? newPayment.cardBrand
            : undefined,
          card_installments:
            newPayment.method === "Tarjeta de Crédito"
              ? newPayment.cardInstallments
              : undefined,
          type: "plan",
          description: paymentDescription,
          plan_id: selectedPlan.id,
        };

        const { error: paymentError } = await supabase
          .from("payments")
          .insert([payment]);
        if (paymentError) throw paymentError;

        const { error: memberError } = await supabase
          .from("members")
          .update({
            balance_due: Math.max(newBalance, 0),
            last_payment: newPayment.date,
            next_installment_due:
              newBalance > 0 ? newPayment.nextInstallmentDue : null,
            status: "active",
          })
          .eq("id", selectedMember.id);
        if (memberError) throw memberError;

        const updatedMember = {
          ...selectedMember,
          balance_due: Math.max(newBalance, 0),
          last_payment: newPayment.date,
          next_installment_due:
            newBalance > 0 ? newPayment.nextInstallmentDue : null,
          status: "active" as const,
        };

        setPayments([...payments, payment]);
        setMembers(
          members.map((m) => (m.id === selectedMember.id ? updatedMember : m))
        );
      } else {
        const payment: Payment = {
          id: paymentId,
          gym_id: gymId,
          member_id: newPayment.memberId,
          member_name: selectedMember.name,
          amount: newPayment.amount,
          date: newPayment.date,
          method: newPayment.method,
          card_brand: ["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
            newPayment.method
          )
            ? newPayment.cardBrand
            : undefined,
          card_installments:
            newPayment.method === "Tarjeta de Crédito"
              ? newPayment.cardInstallments
              : undefined,
          type: "product",
          description: newPayment.description,
          plan: newPayment.description,
        };

        const { error: paymentError } = await supabase
          .from("payments")
          .insert([payment]);
        if (paymentError) throw paymentError;

        setPayments([...payments, payment]);
      }

      // Limpiar formulario
      setNewPayment({
        memberId: "",
        planId: "",
        method: "",
        cardBrand: "",
        cardInstallments: 1,
        date: new Date().toLocaleDateString("en-CA"),
        startDate: new Date().toLocaleDateString("en-CA"),
        type: "new_plan",
        description: "",
        amount: 0,
        installments: 1,
        nextInstallmentDue: new Date().toLocaleDateString("en-CA"),
      });
      setMemberSearchTerm("");
      setPlanContract(null);
      setIsAddDialogOpen(false);
    } catch (error) {
      console.error("Error registrando pago:", error);
      alert("Error al registrar el pago. Inténtalo de nuevo.");
    }
  };

  const openEditDialog = (payment: Payment) => {
    setEditingPayment(payment);
    const customPlanId =
      payment.plan_id ||
      extractCustomPlanIdFromDescription(payment.description) ||
      null;
    setEditingCustomPlanId(customPlanId);
    setEditPaymentData({
      amount: payment.amount,
      date: payment.date,
      method: payment.method,
      cardBrand: payment.card_brand || "",
      cardInstallments: payment.card_installments || 1,
      description:
        payment.type === "custom_plan"
          ? stripCustomPlanMarker(payment.description)
          : payment.description || "",
      startDate: payment.start_date || "",
    });
    setIsEditDialogOpen(true);
  };

  const closeEditDialog = () => {
    setIsEditDialogOpen(false);
    setEditingPayment(null);
    setEditingCustomPlanId(null);
  };

  const handleUpdatePayment = async () => {
    if (!editingPayment) return;

    if (editPaymentData.amount < 0) {
      alert("El monto no puede ser negativo");
      return;
    }

    if (!editPaymentData.method) {
      alert("Selecciona un método de pago");
      return;
    }

    try {
      const trimmedDescription = editPaymentData.description.trim();
      const isCustomPlanPayment = editingPayment.type === "custom_plan";
      const customPlanId =
        editingCustomPlanId ||
        editingPayment.plan_id ||
        extractCustomPlanIdFromDescription(editingPayment.description) ||
        null;

      const resolvedDescription = isCustomPlanPayment
        ? ensureCustomPlanMarker(
            trimmedDescription,
            customPlanId || editingPayment.id
          )
        : trimmedDescription ||
          editingPayment.description ||
          editingPayment.plan ||
          "Pago";
      const paymentUpdate: Record<string, any> = {
        amount: editPaymentData.amount,
        date: editPaymentData.date,
        method: editPaymentData.method,
        card_brand: ["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
          editPaymentData.method
        )
          ? editPaymentData.cardBrand
          : null,
        card_installments:
          editPaymentData.method === "Tarjeta de Crédito"
            ? editPaymentData.cardInstallments
            : null,
        description: resolvedDescription,
      };

      if (typeof editingPayment.start_date === "string") {
        paymentUpdate.start_date = editPaymentData.startDate || null;
      }

      const { error: updateError } = await supabase
        .from("payments")
        .update(paymentUpdate)
        .eq("id", editingPayment.id);

      if (updateError) throw updateError;

      const updatedPayment: Payment = {
        ...editingPayment,
        amount: editPaymentData.amount,
        date: editPaymentData.date,
        method: editPaymentData.method,
        card_brand: ["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
          editPaymentData.method
        )
          ? editPaymentData.cardBrand
          : undefined,
        card_installments:
          editPaymentData.method === "Tarjeta de Crédito"
            ? editPaymentData.cardInstallments
            : undefined,
        description: resolvedDescription,
        ...(typeof editingPayment.start_date === "string"
          ? { start_date: editPaymentData.startDate || undefined }
          : {}),
      };

      const updatedPayments = payments.map((payment) =>
        payment.id === editingPayment.id ? updatedPayment : payment
      );

      if (editingPayment.type === "plan") {
        await updateMemberAfterPlanEdit(
          editingPayment,
          updatedPayments,
          editPaymentData.amount
        );
      }

      setPayments(updatedPayments);
      closeEditDialog();
    } catch (error) {
      console.error("Error actualizando pago:", error);
      alert("Error al actualizar el pago. Inténtalo de nuevo.");
    }
  };

  const handleDeletePayment = async (payment: Payment) => {
    const confirmed = window.confirm(
      "¿Estás seguro de que deseas eliminar este pago?"
    );
    if (!confirmed) return;

    try {
      const { error: deleteError } = await supabase
        .from("payments")
        .delete()
        .eq("id", payment.id);

      if (deleteError) throw deleteError;

      const remainingPayments = payments.filter((p) => p.id !== payment.id);

      if (payment.type === "plan") {
        await revertMemberAfterPlanDeletion(payment, remainingPayments);
        await adjustContractAfterPlanDeletion(payment);
      }

      setPayments(remainingPayments);
    } catch (error) {
      console.error("Error eliminando pago:", error);
      alert("Error al eliminar el pago. Inténtalo de nuevo.");
    }
  };

  const totalPayments = filteredPayments.reduce(
    (sum, payment) => sum + payment.amount,
    0
  );
  const currentMonthPayments = payments.filter((payment) => {
    const paymentDate = parseLocalDate(payment.date);
    const currentDate = new Date();
    return (
      paymentDate.getMonth() === currentDate.getMonth() &&
      paymentDate.getFullYear() === currentDate.getFullYear()
    );
  });

  // Calcular estadísticas por método de pago del mes actual
  const currentMonthPaymentsByMethod = currentMonthPayments.reduce(
    (acc, payment) => {
      acc[payment.method] = (acc[payment.method] || 0) + 1;
      return acc;
    },
    {} as Record<string, number>
  );

  const monthlyTotal = currentMonthPayments.reduce(
    (sum, payment) => sum + payment.amount,
    0
  );

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h2 className="text-3xl font-bold tracking-tight">
            Gestión de Pagos
          </h2>
          <p className="text-muted-foreground">
            Registra pagos y renueva planes de socios existentes
          </p>
        </div>
        <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
          <DialogTrigger asChild>
            <Button>
              <Plus className="mr-2 h-4 w-4" />
              Registrar Pago
            </Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-[900px]">
            <DialogHeader>
              <DialogTitle>Registrar Pago de Socio</DialogTitle>
              <DialogDescription>
                Registra el pago de un socio existente. Si es un plan, se
                renovará automáticamente.
              </DialogDescription>
            </DialogHeader>
            <div className="max-h-[80vh] overflow-y-auto pr-2">
              <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
                {/* BUSCADOR DE SOCIOS */}
                <div className="grid gap-2 md:col-span-2 xl:col-span-3">
                  <Label htmlFor="member-search">Buscar Socio</Label>
                  <div className="relative">
                    <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                    <Input
                      id="member-search"
                      placeholder="Buscar por nombre..."
                      value={memberSearchTerm}
                      onChange={(e) => setMemberSearchTerm(e.target.value)}
                      className="pl-8"
                    />
                  </div>
                  {memberSearchTerm && (
                    <div className="max-h-32 overflow-y-auto border rounded-md">
                      {filteredMembersForSearch.length > 0 ? (
                        filteredMembersForSearch.map((member) => (
                          <div
                            key={member.id}
                            className={`p-2 cursor-pointer transition-colors border-b last:border-b-0 hover:bg-blue-500/10 dark:hover:bg-blue-500/30 ${
                              newPayment.memberId === member.id
                                ? "bg-blue-500/20 dark:bg-blue-500/40"
                                : ""
                            }`}
                            onClick={() => {
                              setNewPayment({
                                ...newPayment,
                                memberId: member.id,
                                planId: "",
                                installments: 1,
                                nextInstallmentDue:
                                  member.next_installment_due ||
                                  new Date().toLocaleDateString("en-CA"),
                              });
                              setMemberSearchTerm(member.name);
                              setPlanContract(null);
                            }}
                          >
                            <div className="font-medium">{member.name}</div>
                            <div className="text-sm text-muted-foreground">
                              Plan actual: {member.plan} - Estado:{" "}
                              {member.status}
                            </div>
                          </div>
                        ))
                      ) : (
                        <div className="p-2 text-sm text-muted-foreground">
                          No se encontraron socios
                        </div>
                      )}
                    </div>
                  )}
                </div>

                {/* TIPO DE PAGO */}
                <div className="grid gap-2">
                  <Label htmlFor="plan">Pago de:</Label>
                  <Select
                    value={newPayment.type}
                    onValueChange={(value) => {
                      setNewPayment({
                        ...newPayment,
                        type: value as "new_plan" | "existing_plan" | "product",
                        planId: "",
                        description: "",
                        amount: 0,
                        installments: 1,
                        nextInstallmentDue: new Date().toLocaleDateString(
                          "en-CA"
                        ),
                      });
                      setPlanContract(null);
                    }}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Selecciona tipo" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="new_plan">Nuevo plan</SelectItem>
                      <SelectItem value="existing_plan">
                        Plan existente
                      </SelectItem>
                      <SelectItem value="product">Producto</SelectItem>
                    </SelectContent>
                  </Select>
                </div>

                {/* SELECCIÓN DE PLAN */}
                {newPayment.type === "new_plan" && (
                  <>
                    <div className="grid gap-2 md:col-span-2 xl:col-span-3">
                      <Label htmlFor="plan">Nuevo Plan</Label>
                      <Select
                        value={newPayment.planId}
                        onValueChange={async (value) => {
                          const selectedPlanOption = plans.find(
                            (plan) => plan.id === value
                          );
                          const computedNext = calculatePlanEndDate(
                            newPayment.startDate,
                            selectedPlanOption
                          );
                          setNewPayment({
                            ...newPayment,
                            planId: value,
                            installments: 1,
                            nextInstallmentDue: computedNext,
                          });
                          if (newPayment.memberId && contractTable) {
                            let { data, error } = await supabase
                              .from(contractTable)
                              .select("*")
                              .eq("member_id", newPayment.memberId)
                              .eq("plan_id", value)
                              .single();
                            if (error) {
                              const fallback = await supabase
                                .from("plan_contract")
                                .select("*")
                                .eq("member_id", newPayment.memberId)
                                .eq("plan_id", value)
                                .single();
                              data = fallback.data;
                            }
                            setPlanContract(data ?? null);
                            if (data) {
                              setNewPayment((prev) => ({
                                ...prev,
                                installments: data.installments_total,
                                nextInstallmentDue:
                                  prev.nextInstallmentDue ||
                                  selectedMember?.next_installment_due ||
                                  computedNext,
                              }));
                            }
                          } else {
                            setPlanContract(null);
                          }
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Selecciona el plan a renovar" />
                        </SelectTrigger>
                        <SelectContent>
                          {plans
                            .filter((plan) => plan.is_active)
                            .map((plan) => (
                              <SelectItem key={plan.id} value={plan.id}>
                                {plan.name} - ${plan.price.toLocaleString()}
                              </SelectItem>
                            ))}
                        </SelectContent>
                      </Select>
                    </div>
                    {newPayment.planId && !planContract && (
                      <div className="grid gap-2">
                        <Label htmlFor="installments">Cantidad de cuotas</Label>
                        <Select
                          value={newPayment.installments.toString()}
                          onValueChange={(value) => {
                            const installments = parseInt(value);
                            const computedNext = calculatePlanEndDate(
                              newPayment.startDate,
                              selectedPlan
                            );
                            setNewPayment({
                              ...newPayment,
                              installments,
                              nextInstallmentDue:
                                installments === 1
                                  ? computedNext
                                  : newPayment.nextInstallmentDue ||
                                    computedNext,
                            });
                          }}
                        >
                          <SelectTrigger>
                            <SelectValue placeholder="Selecciona cuotas" />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="1">1</SelectItem>
                            <SelectItem value="2">2</SelectItem>
                            <SelectItem value="3">3</SelectItem>
                            <SelectItem value="4">4</SelectItem>
                            <SelectItem value="5">5</SelectItem>
                            <SelectItem value="6">6</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>
                    )}
                    {newPayment.planId && planContract && (
                      <div className="text-sm text-muted-foreground md:col-span-2 xl:col-span-3">
                        Cuotas pagadas: {planContract.installments_paid} /{" "}
                        {planContract.installments_total}
                      </div>
                    )}
                    {newPayment.planId && (
                      <div className="grid gap-2">
                        <Label htmlFor="amount">Monto</Label>
                        <Input
                          id="amount"
                          type="number"
                          value={newPayment.amount}
                          max={maxPlanAmount}
                          onChange={(e) =>
                            setNewPayment({
                              ...newPayment,
                              amount: Number(e.target.value),
                            })
                          }
                        />
                        <p className="text-xs text-muted-foreground">
                          Monto máximo: ${maxPlanAmount.toLocaleString()}
                        </p>
                      </div>
                    )}
                    {newPayment.planId && (
                      <div className="grid gap-2">
                        <Label htmlFor="nextInstallmentDue">
                          Vencimiento próxima cuota
                        </Label>
                        <Input
                          id="nextInstallmentDue"
                          type="date"
                          value={nextInstallmentDueValue}
                          onChange={(e) =>
                            setNewPayment({
                              ...newPayment,
                              nextInstallmentDue: e.target.value,
                            })
                          }
                          disabled={newPayment.installments === 1}
                        />
                        <p className="text-xs text-muted-foreground">
                          {newPayment.installments === 1
                            ? "Se utilizará la misma fecha que el fin del plan."
                            : "Registra cuándo debería abonarse la próxima cuota."}
                        </p>
                      </div>
                    )}
                  </>
                )}

                {/* PAGO DE PLAN EXISTENTE */}
                {newPayment.type === "existing_plan" && selectedMember && (
                  <>
                    <div className="grid gap-2">
                      <Label>Plan actual</Label>
                      <Input value={selectedMember.plan} disabled />
                      <p className="text-xs text-muted-foreground">
                        Saldo actual: ${balanceDueActual.toLocaleString()}
                      </p>
                    </div>

                    <div className="grid gap-2">
                      <Label htmlFor="amount">Monto a abonar</Label>
                      <Input
                        id="amount"
                        type="number"
                        value={newPayment.amount}
                        max={balanceDueActual}
                        onChange={(e) =>
                          setNewPayment({
                            ...newPayment,
                            amount: Number(e.target.value),
                          })
                        }
                      />
                      {newPayment.amount > 0 && (
                        <p className="text-xs text-muted-foreground">
                          Saldo restante: ${remainingBalance.toLocaleString()}
                        </p>
                      )}
                    </div>
                    {shouldAskNextInstallmentDue && (
                      <div className="grid gap-2">
                        <Label htmlFor="existingNextInstallmentDue">
                          Vencimiento próxima cuota
                        </Label>
                        <Input
                          id="existingNextInstallmentDue"
                          type="date"
                          value={
                            newPayment.nextInstallmentDue ||
                            selectedMember.next_installment_due ||
                            ""
                          }
                          onChange={(e) =>
                            setNewPayment({
                              ...newPayment,
                              nextInstallmentDue: e.target.value,
                            })
                          }
                        />
                        <p className="text-xs text-muted-foreground">
                          Define el nuevo vencimiento para la próxima cuota
                          pendiente.
                        </p>
                      </div>
                    )}
                  </>
                )}

                {/* CAMPOS DE PRODUCTO */}
                {newPayment.type === "product" && (
                  <div className="grid gap-2">
                    <Label htmlFor="amount">Monto</Label>
                    <Input
                      id="amount"
                      type="number"
                      value={newPayment.amount}
                      onChange={(e) =>
                        setNewPayment({
                          ...newPayment,
                          amount: parseFloat(e.target.value),
                        })
                      }
                    />
                  </div>
                )}

                {/* MÉTODO DE PAGO */}
                <div className="grid gap-2">
                  <Label htmlFor="method">Método de Pago</Label>
                  <Select
                    value={newPayment.method}
                    onValueChange={(value) =>
                      setNewPayment({ ...newPayment, method: value })
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Selecciona método" />
                    </SelectTrigger>
                    <SelectContent>
                      {paymentMethods.map((method) => (
                        <SelectItem key={method} value={method}>
                          {method}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                {["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
                  newPayment.method
                ) && (
                  <>
                    <div className="grid gap-2">
                      <Label htmlFor="cardBrand">Tipo de Tarjeta</Label>
                      <Select
                        value={newPayment.cardBrand}
                        onValueChange={(value) =>
                          setNewPayment({ ...newPayment, cardBrand: value })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Selecciona tarjeta" />
                        </SelectTrigger>
                        <SelectContent>
                          {cardBrands.map((brand) => (
                            <SelectItem key={brand} value={brand}>
                              {brand}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                    <div className="grid gap-2">
                      <Label htmlFor="cardInstallments">
                        Número de cuotas en la tarjeta
                      </Label>
                      <Input
                        id="cardInstallments"
                        type="number"
                        min={1}
                        value={newPayment.cardInstallments}
                        onChange={(e) =>
                          setNewPayment({
                            ...newPayment,
                            cardInstallments: parseInt(e.target.value) || 1,
                          })
                        }
                      />
                    </div>
                  </>
                )}

                {/* FECHA */}
                <div className="grid gap-2">
                  <Label htmlFor="date">Fecha del Pago</Label>
                  <Input
                    id="date"
                    type="date"
                    value={newPayment.date}
                    onChange={(e) =>
                      setNewPayment({ ...newPayment, date: e.target.value })
                    }
                  />
                </div>

                {newPayment.type === "new_plan" && (
                  <div className="grid gap-2 md:col-span-2 xl:col-span-3">
                    <Label htmlFor="startDate">Fecha de inicio del plan</Label>
                    <Input
                      id="startDate"
                      type="date"
                      value={newPayment.startDate}
                      onChange={(e) => {
                        const value = e.target.value;
                        const computedNext = calculatePlanEndDate(
                          value,
                          selectedPlan
                        );
                        setNewPayment({
                          ...newPayment,
                          startDate: value,
                          nextInstallmentDue:
                            newPayment.installments === 1
                              ? computedNext
                              : newPayment.nextInstallmentDue || computedNext,
                        });
                      }}
                    />
                    <p className="text-xs text-muted-foreground">
                      El plan se calculará desde esta fecha (útil si se registra
                      con atraso)
                    </p>
                  </div>
                )}

                {/* DESCRIPCIÓN */}
                <div className="grid gap-2 md:col-span-2 xl:col-span-3">
                  <Label htmlFor="description">Descripción</Label>
                  <Input
                    id="description"
                    value={newPayment.description}
                    onChange={(e) =>
                      setNewPayment({
                        ...newPayment,
                        description: e.target.value,
                      })
                    }
                  />
                </div>

                {/* RESUMEN */}
                {newPayment.type === "new_plan" &&
                  newPayment.memberId &&
                  newPayment.planId &&
                  newPayment.amount > 0 && (
                    <div className="p-3 bg-green-50 rounded-lg md:col-span-2 xl:col-span-3">
                      <h4 className="font-medium text-green-800 mb-2">
                        Resumen de Renovación
                      </h4>
                      <div className="text-sm text-green-700">
                        <p>
                          <strong>Socio:</strong>{" "}
                          {
                            members.find((m) => m.id === newPayment.memberId)
                              ?.name
                          }
                        </p>
                        <p>
                          <strong>Plan:</strong>{" "}
                          {plans.find((p) => p.id === newPayment.planId)?.name}
                        </p>
                        <p>
                          <strong>Monto:</strong> $
                          {newPayment.amount.toLocaleString()}
                        </p>
                        <p className="mt-1 text-xs">
                          ✅ El socio se activará y se actualizará su próximo
                          vencimiento
                        </p>
                      </div>
                    </div>
                  )}
                {newPayment.type === "existing_plan" &&
                  newPayment.memberId &&
                  newPayment.amount > 0 && (
                    <div className="p-3 bg-green-50 rounded-lg md:col-span-2 xl:col-span-3">
                      <h4 className="font-medium text-green-800 mb-2">
                        Resumen de Pago
                      </h4>
                      <div className="text-sm text-green-700">
                        <p>
                          <strong>Socio:</strong>{" "}
                          {
                            members.find((m) => m.id === newPayment.memberId)
                              ?.name
                          }
                        </p>
                        <p>
                          <strong>Plan:</strong> {selectedMember?.plan}
                        </p>
                        <p>
                          <strong>Monto:</strong> $
                          {newPayment.amount.toLocaleString()}
                        </p>
                        <p className="mt-1 text-xs">
                          Saldo restante: ${remainingBalance.toLocaleString()}
                        </p>
                        {shouldAskNextInstallmentDue &&
                          newPayment.nextInstallmentDue && (
                            <p className="text-xs text-muted-foreground">
                              Próximo vencimiento:{" "}
                              {newPayment.nextInstallmentDue}
                            </p>
                          )}
                      </div>
                    </div>
                  )}
                {newPayment.type === "product" &&
                  newPayment.memberId &&
                  newPayment.description &&
                  newPayment.amount > 0 && (
                    <div className="p-3 bg-green-50 rounded-lg md:col-span-2 xl:col-span-3">
                      <h4 className="font-medium text-green-800 mb-2">
                        Resumen de Venta
                      </h4>
                      <div className="text-sm text-green-700">
                        <p>
                          <strong>Socio:</strong>{" "}
                          {
                            members.find((m) => m.id === newPayment.memberId)
                              ?.name
                          }
                        </p>
                        <p>
                          <strong>Descripción:</strong> {newPayment.description}
                        </p>
                        <p>
                          <strong>Monto:</strong> $
                          {newPayment.amount.toLocaleString()}
                        </p>
                      </div>
                    </div>
                  )}
              </div>
            </div>
            <DialogFooter>
              <Button
                type="submit"
                onClick={handleAddPayment}
                disabled={
                  !newPayment.memberId ||
                  !newPayment.method ||
                  (["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
                    newPayment.method
                  ) &&
                    !newPayment.cardBrand) ||
                  (newPayment.type === "new_plan"
                    ? !newPayment.planId ||
                      !newPayment.startDate ||
                      Number.isNaN(newPayment.amount) ||
                      newPayment.amount < 0
                    : newPayment.type === "existing_plan"
                    ? Number.isNaN(newPayment.amount) ||
                      newPayment.amount < 0 ||
                      (shouldAskNextInstallmentDue &&
                        !newPayment.nextInstallmentDue)
                    : !newPayment.description || !newPayment.amount)
                }
              >
                Registrar Pago
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      </div>

      {/* Summary Cards - AGREGAR TARJETAS DE MÉTODOS */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-5">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              Total Pagos (Filtrado)
            </CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${totalPayments.toLocaleString()}
            </div>
            <p className="text-xs text-muted-foreground">
              {filteredPayments.length} pagos
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Mes Actual</CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${monthlyTotal.toLocaleString()}
            </div>
            <p className="text-xs text-muted-foreground">
              {currentMonthPayments.length} pagos este mes
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              Efectivo (Mes)
            </CardTitle>
            <div className="w-3 h-3 bg-green-500 rounded-full"></div>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-green-600">
              {currentMonthPaymentsByMethod["Efectivo"] || 0}
            </div>
            <p className="text-xs text-muted-foreground">pagos en efectivo</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Débito (Mes)</CardTitle>
            <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-blue-600">
              {currentMonthPaymentsByMethod["Tarjeta de Débito"] || 0}
            </div>
            <p className="text-xs text-muted-foreground">pagos con débito</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Crédito (Mes)</CardTitle>
            <div className="w-3 h-3 bg-purple-500 rounded-full"></div>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-purple-600">
              {currentMonthPaymentsByMethod["Tarjeta de Crédito"] || 0}
            </div>
            <p className="text-xs text-muted-foreground">pagos con crédito</p>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle>Filtros</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex gap-4">
            <div className="flex-1">
              <div className="relative">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Buscar por nombre del socio..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-8"
                />
              </div>
            </div>
            <Select value={methodFilter} onValueChange={setMethodFilter}>
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Método de pago" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los métodos</SelectItem>
                <SelectItem value="Efectivo">Efectivo</SelectItem>
                <SelectItem value="Transferencia">Transferencia</SelectItem>
                <SelectItem value="Tarjeta de Débito">
                  Tarjeta de Débito
                </SelectItem>
                <SelectItem value="Tarjeta de Crédito">
                  Tarjeta de Crédito
                </SelectItem>
              </SelectContent>
            </Select>
            <Select value={periodFilter} onValueChange={setPeriodFilter}>
              <SelectTrigger className="w-[200px]">
                <SelectValue placeholder="Período" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los períodos</SelectItem>
                <SelectItem value="current_month">Mes actual</SelectItem>
                <SelectItem value="previous_month">Mes anterior</SelectItem>
                <SelectItem value="last_6_months">Últimos 6 meses</SelectItem>
                <SelectItem value="current_year">Año actual</SelectItem>
              </SelectContent>
            </Select>
            <Select
              value={referenceFilter}
              onValueChange={(value) =>
                setReferenceFilter(value as ReferenceFilterOption)
              }
            >
              <SelectTrigger className="w-[220px]">
                <SelectValue placeholder="Referencia del pago" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los tipos</SelectItem>
                <SelectItem value="new_plan">Plan nuevo</SelectItem>
                <SelectItem value="existing_plan">Plan existente</SelectItem>
                <SelectItem value="product">Producto</SelectItem>
                <SelectItem value="custom_plan">Plan personalizado</SelectItem>
              </SelectContent>
            </Select>
            <Select
              value={installmentFilter}
              onValueChange={setInstallmentFilter}
            >
              <SelectTrigger className="w-[220px]">
                <SelectValue placeholder="Estado de cuotas" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Todos los estados</SelectItem>
                <SelectItem value="pending_balance">
                  Con saldo pendiente
                </SelectItem>
                <SelectItem value="due_soon">
                  Próximos a vencer (10 días)
                </SelectItem>
                <SelectItem value="overdue">Cuotas vencidas</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Payments Table */}
      <Card>
        <CardHeader>
          <CardTitle>Historial de Pagos ({filteredPayments.length})</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Fecha</TableHead>
                <TableHead>Socio</TableHead>
                <TableHead>Detalle</TableHead>
                <TableHead>Monto pagado</TableHead>
                <TableHead>Método</TableHead>
                <TableHead>En cuotas</TableHead>
                <TableHead>Saldo pendiente</TableHead>
                <TableHead>Vencimiento próxima cuota</TableHead>
                <TableHead>Tipo</TableHead>
                <TableHead>Acciones</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {visiblePayments.map((payment) => {
                const insight = paymentInsights.get(payment.id);
                const member = membersById.get(payment.member_id);
                const fallbackBalance =
                  typeof member?.balance_due === "number"
                    ? member.balance_due
                    : null;
                const insightBalance =
                  typeof insight?.balancePending === "number"
                    ? insight.balancePending
                    : null;
                const balanceValue = insightBalance ?? fallbackBalance ?? null;
                const isPlanPayment = !payment.type || payment.type === "plan";
                const isCustomPlanPayment = payment.type === "custom_plan";
                const customPlanId = isCustomPlanPayment
                  ? payment.plan_id ||
                    extractCustomPlanIdFromDescription(payment.description)
                  : null;
                const relatedCustomPlan = customPlanId
                  ? customPlansById.get(customPlanId) ?? null
                  : null;
                const customPlanEndDate = relatedCustomPlan?.end_date ?? null;
                const formattedCustomPlanDue = formatDueDate(customPlanEndDate);
                const hasPendingInstallment =
                  isPlanPayment && (balanceValue ?? 0) > 0;
                const nextInstallmentDueRaw =
                  insight?.nextInstallmentDue ??
                  member?.next_installment_due ??
                  null;
                const nextInstallmentDueDate = parseDueDate(
                  nextInstallmentDueRaw
                );
                const formattedNextDue = formatDueDate(nextInstallmentDueRaw);
                let dueStatusClass = "text-muted-foreground";
                if (hasPendingInstallment && nextInstallmentDueDate) {
                  const today = new Date();
                  today.setHours(0, 0, 0, 0);
                  const limitDate = new Date(today);
                  limitDate.setDate(limitDate.getDate() + 10);
                  if (nextInstallmentDueDate < today) {
                    dueStatusClass = "font-semibold text-red-600";
                  } else if (nextInstallmentDueDate <= limitDate) {
                    dueStatusClass = "font-semibold text-amber-600";
                  } else {
                    dueStatusClass = "text-green-600";
                  }
                }
                if (hasPendingInstallment && !nextInstallmentDueDate) {
                  dueStatusClass = "font-semibold text-amber-600";
                }
                const nextInstallmentDueDisplay = hasPendingInstallment
                  ? formattedNextDue ?? "Sin definir"
                  : "No corresponde";
                let dueCellContent = (
                  <span className="text-muted-foreground">-</span>
                );
                if (isPlanPayment && balanceValue !== null) {
                  dueCellContent = (
                    <span className={dueStatusClass}>
                      {nextInstallmentDueDisplay}
                    </span>
                  );
                } else if (isCustomPlanPayment) {
                  dueCellContent = (
                    <span className="text-muted-foreground">
                      {formattedCustomPlanDue ?? "Sin fecha definida"}
                    </span>
                  );
                }
                const isAutoGeneratedPayment =
                  isAutoGeneratedOneTimePayment(payment);
                const detailDescription = isCustomPlanPayment
                  ? stripCustomPlanMarker(payment.description)
                  : payment.description;
                const detailLabel = isPlanPayment
                  ? payment.plan
                  : payment.plan ?? detailDescription;
                const rawDetailAmount = isPlanPayment
                  ? insight?.planPrice ?? member?.plan_price ?? payment.amount
                  : payment.amount;
                const formattedDetailAmount = new Intl.NumberFormat("es-AR", {
                  minimumFractionDigits: 0,
                  maximumFractionDigits: 2,
                  useGrouping: false,
                }).format(rawDetailAmount ?? payment.amount);
                const detailDisplay = detailLabel?.trim()
                  ? `${detailLabel} - $${formattedDetailAmount}`
                  : `Sin detalle - $${formattedDetailAmount}`;
                const relatedInvoice =
                  invoicesByPaymentId.get(payment.id) ?? null;
                const isProcessingInvoice =
                  isSendingInvoice && invoicePayment?.id === payment.id;

                return (
                  <TableRow key={payment.id}>
                    <TableCell>
                      {parseLocalDate(payment.date).toLocaleDateString()}
                    </TableCell>
                    <TableCell className="font-medium">
                      {payment.member_name}
                    </TableCell>
                    <TableCell>{detailDisplay}</TableCell>
                    <TableCell className="font-medium text-green-600">
                      ${payment.amount.toLocaleString()}
                    </TableCell>
                    <TableCell>
                      {payment.method}
                      {payment.card_brand ? ` - ${payment.card_brand}` : ""}
                    </TableCell>
                    <TableCell>
                      {isPlanPayment ? (
                        insight?.isInstallment ? (
                          <Badge variant="secondary">Sí</Badge>
                        ) : (
                          <Badge variant="outline">No</Badge>
                        )
                      ) : (
                        <Badge variant="outline">N/A</Badge>
                      )}
                    </TableCell>
                    <TableCell>
                      {isPlanPayment && balanceValue !== null ? (
                        <span
                          className={
                            balanceValue > 0
                              ? "font-semibold text-amber-600"
                              : "text-muted-foreground"
                          }
                        >
                          ${balanceValue.toLocaleString()}
                        </span>
                      ) : (
                        <span className="text-muted-foreground">-</span>
                      )}
                    </TableCell>
                    <TableCell>{dueCellContent}</TableCell>
                    <TableCell className="capitalize">
                      {isAutoGeneratedPayment
                        ? "Pago único"
                        : isCustomPlanPayment
                        ? "Plan personalizado"
                        : isPlanPayment
                        ? "Plan"
                        : payment.type || "Plan"}
                    </TableCell>

                    <TableCell>
                      {isAutoGeneratedPayment ? (
                        <span className="text-xs text-muted-foreground">
                          Pago automático
                        </span>
                      ) : (
                        <div className="flex gap-2">
                          <Button
                            variant={relatedInvoice ? "secondary" : "outline"}
                            size="sm"
                            className="inline-flex items-center gap-1"
                            onClick={() =>
                              openInvoiceDialog(payment, relatedInvoice)
                            }
                            disabled={
                              isProcessingInvoice ||
                              (!relatedInvoice && !isInvoiceConfigReady)
                            }
                            title={
                              relatedInvoice
                                ? "Ver factura generada"
                                : isInvoiceConfigReady
                                ? "Facturar este pago"
                                : `Configura ${missingInvoiceConfig.join(
                                    ", "
                                  )} y la contraseña invoice_password en Supabase para habilitar la facturación.`
                            }
                          >
                            <Receipt className="h-4 w-4" />
                            {relatedInvoice ? "Ver" : "Facturar"}
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => openEditDialog(payment)}
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleDeletePayment(payment)}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      )}
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
          <div className="mt-4 flex flex-col gap-3 md:flex-row md:items-center md:justify-between">
            <div className="text-sm text-muted-foreground">
              {filteredPayments.length > 0 && (
                <>
                  Mostrando <strong>{visiblePayments.length}</strong> de{" "}
                  <strong>{filteredPayments.length}</strong> pagos cargados
                </>
              )}
            </div>
            {canLoadMore && (
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleLoadMorePayments}
                >
                  Cargar más pagos
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>
      <Dialog
        open={isEditDialogOpen}
        onOpenChange={(open) => {
          setIsEditDialogOpen(open);
          if (!open) {
            setEditingPayment(null);
          }
        }}
      >
        <DialogContent className="sm:max-w-[500px]">
          <DialogHeader>
            <DialogTitle>Editar pago</DialogTitle>
            <DialogDescription>
              Actualiza la información del pago seleccionado.
            </DialogDescription>
          </DialogHeader>
          {editingPayment && (
            <div className="grid gap-4 py-4">
              <div className="grid gap-2">
                <Label htmlFor="edit-date">Fecha del Pago</Label>
                <Input
                  id="edit-date"
                  type="date"
                  value={editPaymentData.date}
                  onChange={(e) =>
                    setEditPaymentData({
                      ...editPaymentData,
                      date: e.target.value,
                    })
                  }
                />
              </div>
              {typeof editingPayment.start_date === "string" && (
                <div className="grid gap-2">
                  <Label htmlFor="edit-start-date">Inicio del Plan</Label>
                  <Input
                    id="edit-start-date"
                    type="date"
                    value={editPaymentData.startDate}
                    onChange={(e) =>
                      setEditPaymentData({
                        ...editPaymentData,
                        startDate: e.target.value,
                      })
                    }
                  />
                </div>
              )}
              <div className="grid gap-2">
                <Label htmlFor="edit-amount">Monto</Label>
                <Input
                  id="edit-amount"
                  type="number"
                  min={0}
                  value={editPaymentData.amount}
                  onChange={(e) =>
                    setEditPaymentData({
                      ...editPaymentData,
                      amount: Number(e.target.value) || 0,
                    })
                  }
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="edit-method">Método de Pago</Label>
                <Select
                  value={editPaymentData.method}
                  onValueChange={(value) =>
                    setEditPaymentData((prev) => ({
                      ...prev,
                      method: value,
                      cardBrand: [
                        "Tarjeta de Crédito",
                        "Tarjeta de Débito",
                      ].includes(value)
                        ? prev.cardBrand
                        : "",
                      cardInstallments:
                        value === "Tarjeta de Crédito"
                          ? prev.cardInstallments
                          : 1,
                    }))
                  }
                >
                  <SelectTrigger id="edit-method">
                    <SelectValue placeholder="Selecciona método" />
                  </SelectTrigger>
                  <SelectContent>
                    {paymentMethods.map((method) => (
                      <SelectItem key={method} value={method}>
                        {method}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
              {["Tarjeta de Crédito", "Tarjeta de Débito"].includes(
                editPaymentData.method
              ) && (
                <>
                  <div className="grid gap-2">
                    <Label htmlFor="edit-card-brand">Tipo de Tarjeta</Label>
                    <Select
                      value={editPaymentData.cardBrand}
                      onValueChange={(value) =>
                        setEditPaymentData((prev) => ({
                          ...prev,
                          cardBrand: value,
                        }))
                      }
                    >
                      <SelectTrigger id="edit-card-brand">
                        <SelectValue placeholder="Selecciona tarjeta" />
                      </SelectTrigger>
                      <SelectContent>
                        {cardBrands.map((brand) => (
                          <SelectItem key={brand} value={brand}>
                            {brand}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="edit-card-installments">
                      Número de cuotas en la tarjeta
                    </Label>
                    <Input
                      id="edit-card-installments"
                      type="number"
                      min={1}
                      value={editPaymentData.cardInstallments}
                      onChange={(e) =>
                        setEditPaymentData({
                          ...editPaymentData,
                          cardInstallments: parseInt(e.target.value) || 1,
                        })
                      }
                    />
                  </div>
                </>
              )}
              <div className="grid gap-2">
                <Label htmlFor="edit-description">Descripción</Label>
                <Input
                  id="edit-description"
                  value={editPaymentData.description}
                  onChange={(e) =>
                    setEditPaymentData({
                      ...editPaymentData,
                      description: e.target.value,
                    })
                  }
                />
              </div>
            </div>
          )}
          <DialogFooter>
            <Button variant="outline" onClick={closeEditDialog}>
              Cancelar
            </Button>
            <Button onClick={handleUpdatePayment}>Guardar cambios</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      <Dialog
        open={isInvoiceDialogOpen}
        onOpenChange={(open) => {
          if (open) {
            setIsInvoiceDialogOpen(true);
          } else {
            closeInvoiceDialog();
          }
        }}
      >
        <DialogContent className="sm:max-w-[680px] max-h-[85vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              {invoiceDialogMode === "view"
                ? "Factura generada"
                : "Facturar pago"}
            </DialogTitle>
            <DialogDescription>
              {invoiceDialogMode === "view"
                ? "Consulta la información registrada para este comprobante."
                : "Revisa y confirma los datos antes de enviar la factura electrónica."}
            </DialogDescription>
          </DialogHeader>
          {invoicePayment && invoiceDialogMode === "create" && invoiceForm && (
            <div className="space-y-4 py-2">
              <div className="rounded-md border p-3 text-sm space-y-1">
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Socio</span>
                  <span className="font-medium text-right">
                    {invoicePayment.member_name}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Monto</span>
                  <span className="font-semibold text-green-600">
                    ${invoicePayment.amount.toLocaleString()}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Fecha del pago</span>
                  <span>
                    {parseLocalDate(invoicePayment.date).toLocaleDateString()}
                  </span>
                </div>
              </div>
              <div className="grid gap-4 md:grid-cols-2">
                <div className="grid gap-2">
                  <Label htmlFor="invoice-facturareferencia">
                    Referencia interna
                  </Label>
                  <Input
                    id="invoice-facturareferencia"
                    value={invoiceForm.facturareferencia}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "facturareferencia",
                        event.target.value
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-serie">Serie referencia</Label>
                  <Input
                    id="invoice-serie"
                    value={invoiceForm.seriereferencia}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "seriereferencia",
                        event.target.value
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-fecha">Fecha de facturación</Label>
                  <Input
                    id="invoice-fecha"
                    type="date"
                    value={invoiceForm.fechafacturacion}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "fechafacturacion",
                        event.target.value
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-fecha-venc">
                    Fecha de vencimiento
                  </Label>
                  <Input
                    id="invoice-fecha-venc"
                    type="date"
                    value={invoiceForm.fechavencimiento}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "fechavencimiento",
                        event.target.value
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-moneda">Moneda</Label>
                  <Input
                    id="invoice-moneda"
                    value={invoiceForm.moneda}
                    onChange={(event) =>
                      handleInvoiceFieldChange("moneda", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label>Método de cobro</Label>
                  <Select
                    value={String(invoiceForm.payment_type)}
                    onValueChange={(value) =>
                      handleInvoiceFieldChange("payment_type", Number(value))
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Selecciona el método" />
                    </SelectTrigger>
                    <SelectContent>
                      {facturaPaymentTypeOptions.map((option) => (
                        <SelectItem
                          key={option.value}
                          value={String(option.value)}
                        >
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-cotizacion">Cotización</Label>
                  <Input
                    id="invoice-cotizacion"
                    type="number"
                    step="0.01"
                    value={invoiceForm.cotizacion}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "cotizacion",
                        Number(event.target.value) || 0
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-typecfe">Tipo CFE</Label>
                  <Input
                    id="invoice-typecfe"
                    type="number"
                    value={invoiceForm.typecfe}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "typecfe",
                        Number(event.target.value) || 0
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-typedoc">Tipo de documento</Label>
                  <Input
                    id="invoice-typedoc"
                    type="number"
                    value={invoiceForm.typedoc}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "typedoc",
                        Number(event.target.value) || 0
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-traslado">Tipo de traslado</Label>
                  <Input
                    id="invoice-traslado"
                    type="number"
                    value={invoiceForm.TipoTraslado}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "TipoTraslado",
                        Number(event.target.value) || 0
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-environment">Ambiente</Label>
                  <Select
                    value={invoiceForm.environment}
                    onValueChange={(value) =>
                      handleInvoiceFieldChange("environment", value)
                    }
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Selecciona ambiente" />
                    </SelectTrigger>
                    <SelectContent>
                      {facturaEnvironmentOptions.map((option) => (
                        <SelectItem key={option} value={option}>
                          {option}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-facturaext">ID externo</Label>
                  <Input
                    id="invoice-facturaext"
                    value={invoiceForm.facturaext}
                    onChange={(event) =>
                      handleInvoiceFieldChange("facturaext", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-periodo-desde">Período desde</Label>
                  <Input
                    id="invoice-periodo-desde"
                    type="date"
                    value={invoiceForm.periododesde}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "periododesde",
                        event.target.value
                      )
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-periodo-hasta">Período hasta</Label>
                  <Input
                    id="invoice-periodo-hasta"
                    type="date"
                    value={invoiceForm.periodohasta}
                    onChange={(event) =>
                      handleInvoiceFieldChange(
                        "periodohasta",
                        event.target.value
                      )
                    }
                  />
                </div>
              </div>
              <div className="grid gap-4 md:grid-cols-2">
                <div className="grid gap-2">
                  <Label htmlFor="invoice-nomneg">Nombre / Razón social</Label>
                  <Input
                    id="invoice-nomneg"
                    value={invoiceForm.nomneg}
                    onChange={(event) =>
                      handleInvoiceFieldChange("nomneg", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-rutneg">RUT / Documento</Label>
                  <Input
                    id="invoice-rutneg"
                    value={invoiceForm.rutneg}
                    onChange={(event) =>
                      handleInvoiceFieldChange("rutneg", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-dirneg">Dirección</Label>
                  <Input
                    id="invoice-dirneg"
                    value={invoiceForm.dirneg}
                    onChange={(event) =>
                      handleInvoiceFieldChange("dirneg", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-cityneg">Ciudad</Label>
                  <Input
                    id="invoice-cityneg"
                    value={invoiceForm.cityneg}
                    onChange={(event) =>
                      handleInvoiceFieldChange("cityneg", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-stateneg">
                    Departamento / Estado
                  </Label>
                  <Input
                    id="invoice-stateneg"
                    value={invoiceForm.stateneg}
                    onChange={(event) =>
                      handleInvoiceFieldChange("stateneg", event.target.value)
                    }
                  />
                </div>
                <div className="grid gap-2">
                  <Label htmlFor="invoice-country">País</Label>
                  <Input
                    id="invoice-country"
                    value={invoiceForm.clicountry}
                    onChange={(event) =>
                      handleInvoiceFieldChange("clicountry", event.target.value)
                    }
                  />
                </div>
              </div>
              <div className="grid gap-2">
                <Label htmlFor="invoice-addinfoneg">
                  Información adicional cliente
                </Label>
                <Textarea
                  id="invoice-addinfoneg"
                  value={invoiceForm.addinfoneg}
                  onChange={(event) =>
                    handleInvoiceFieldChange("addinfoneg", event.target.value)
                  }
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="invoice-lineas">Líneas de la factura</Label>
                <Textarea
                  id="invoice-lineas"
                  value={invoiceForm.lineas}
                  onChange={(event) =>
                    handleInvoiceFieldChange("lineas", event.target.value)
                  }
                  className="font-mono text-xs"
                  rows={3}
                />
                <p className="text-xs text-muted-foreground">
                  Utiliza el formato requerido por FacturaLive (campos separados
                  por <code>&lt;col/&gt;</code> y productos separados por coma).
                </p>
              </div>
              <div className="grid gap-2">
                <Label htmlFor="invoice-additionalinfo">
                  Información adicional en factura
                </Label>
                <Textarea
                  id="invoice-additionalinfo"
                  value={invoiceForm.additionalinfo}
                  onChange={(event) =>
                    handleInvoiceFieldChange(
                      "additionalinfo",
                      event.target.value
                    )
                  }
                  rows={2}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="invoice-terms">Términos y condiciones</Label>
                <Textarea
                  id="invoice-terms"
                  value={invoiceForm.terms_conditions}
                  onChange={(event) =>
                    handleInvoiceFieldChange(
                      "terms_conditions",
                      event.target.value
                    )
                  }
                  rows={2}
                />
              </div>
              <div className="grid gap-2">
                <Label htmlFor="invoice-indicador">
                  Indicador de facturación
                </Label>
                <Input
                  id="invoice-indicador"
                  value={invoiceForm.indicadorfacturacion}
                  onChange={(event) =>
                    handleInvoiceFieldChange(
                      "indicadorfacturacion",
                      event.target.value
                    )
                  }
                />
              </div>
              {invoiceError && (
                <p className="text-sm text-red-600">{invoiceError}</p>
              )}
              {invoiceErrorDetails && (
                <div className="rounded-md border border-red-200 bg-red-50 p-3 text-xs text-red-700">
                  <p className="font-semibold">Detalle técnico</p>
                  <pre className="mt-2 max-h-48 overflow-auto whitespace-pre-wrap break-words">
                    {invoiceErrorDetails}
                  </pre>
                </div>
              )}
              {invoiceDebugSteps.length > 0 && (
                <div className="rounded-md border border-muted-foreground/20 bg-muted/40 p-3 text-xs text-muted-foreground">
                  <p className="font-semibold text-foreground">Registro de depuración</p>
                  <ol className="mt-2 space-y-2">
                    {invoiceDebugSteps.map((entry, index) => (
                      <li key={`${entry.at}-${index}`} className="space-y-1">
                        <div className="flex flex-wrap items-center justify-between gap-2">
                          <span className="font-medium text-foreground">
                            {index + 1}. [{SOURCE_LABELS[entry.source]}] {entry.step}
                          </span>
                          <span className="whitespace-nowrap text-muted-foreground">
                            {formatDebugStepTimestamp(entry.at)}
                          </span>
                        </div>
                        {entry.data !== undefined && entry.data !== null && (
                          <pre className="max-h-32 overflow-auto rounded bg-background/70 p-2 text-[11px] leading-relaxed text-muted-foreground">
                            {formatDebugStepData(entry.data)}
                          </pre>
                        )}
                      </li>
                    ))}
                  </ol>
                </div>
              )}
              {invoiceSuccess && (
                <p className="text-sm text-green-600">{invoiceSuccess}</p>
              )}
            </div>
          )}
          {invoiceDialogMode === "view" && selectedInvoiceRecord && (
            <div className="space-y-4 py-2">
              {invoiceSuccess && (
                <div className="rounded-md border border-green-200 bg-green-50 p-3 text-sm text-green-700">
                  {invoiceSuccess}
                </div>
              )}
              <div className="grid gap-2 text-sm">
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Estado</span>
                  <Badge variant="outline">
                    {selectedInvoiceRecord.status || "Sin estado"}
                  </Badge>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Monto</span>
                  <span className="font-semibold text-green-600">
                    ${selectedInvoiceRecord.total.toLocaleString()}{" "}
                    {selectedInvoiceRecord.currency || "UYU"}
                  </span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Número</span>
                  <span>{selectedInvoiceRecord.invoice_number ?? "-"}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Serie</span>
                  <span>{selectedInvoiceRecord.invoice_series ?? "-"}</span>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-muted-foreground">Ambiente</span>
                  <Badge variant="outline">
                    {selectedInvoiceRecord.environment || "TEST"}
                  </Badge>
                </div>
                <div>
                  <span className="text-muted-foreground block text-xs uppercase">
                    Datos enviados
                  </span>
                  <pre className="max-h-40 overflow-auto rounded-md bg-muted p-3 text-xs">
                    {JSON.stringify(
                      selectedInvoiceRecord.request_payload ?? {},
                      null,
                      2
                    )}
                  </pre>
                </div>
                <div>
                  <span className="text-muted-foreground block text-xs uppercase">
                    Respuesta del servicio
                  </span>
                  <pre className="max-h-40 overflow-auto rounded-md bg-muted p-3 text-xs">
                    {JSON.stringify(
                      selectedInvoiceRecord.response_payload ?? {},
                      null,
                      2
                    )}
                  </pre>
                </div>
              </div>
            </div>
          )}
          <DialogFooter>
            <Button variant="outline" onClick={closeInvoiceDialog}>
              Cerrar
            </Button>
            {invoiceDialogMode === "create" && (
              <Button onClick={handleSendInvoice} disabled={isSendingInvoice}>
                {isSendingInvoice ? "Enviando…" : "Confirmar y facturar"}
              </Button>
            )}
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
